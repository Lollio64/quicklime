# SL model format

Each file represents a single 3D object as well as the name of the material to dictate how it is drawn.

Models must be centred on (0, 0, 0):

This means if you have for example a cube, it should be positioned so that the centre of the cube is at (0, 0, 0).

This should just be as close as possible, if it's not perfect it likely won't cause issues but the further away it is the weirder it will look with frustum culling. To have an object default as offset from (0, 0, 0), set its position in the scene file instead. The model converter script might do the first part for you (depends if i implement it) but the second part is entirely on the dev to do. If I ever have a UI thing, it should make it pretty obvious that this needs doing

## Sections

### Header

Format:
| Offset | Size | Type    | Description                 |
|--------|------|---------|-----------------------------|
| 0x0    | 0x4  | char[]  | Magic "mdl"                 |
| 0x4    | 0x4  | u32     | Number of vertices          |
| 0x8    | 0x4  | u32     | Vertex size                 |
| 0xc    | 0x4  | float32 | Bounding sphere radius      |
| 0x10   | 0x4  | u32     | Number of vertex attributes |
| 0x14   | 0x10 | u8[16]  | Type of each attribute      |
| 0x24   | 0x10 | u8[16]  | Size of each attribute      |

### Object section

This section is basically just the binary representation of an array of vertices, following the layout given in the header

So:

With a vertex laid out as { position[3], texcoord[2], normal[3]} (32 bytes long)

- bytes 0-3 represent (vertex 0).position[0]
- bytes 4-7 represent (vertex 0).position[1]
- bytes 8-11 represent (vertex 0).position[2]

- bytes 12-15 represent (vertex 0).texcoord[0]
- bytes 16-19 represent (vertex 0).texcoord[1]

- bytes 20-23 represent (vertex 0).normal[0]
- bytes 24-27 represent (vertex 0).normal[1]
- bytes 28-31 represent (vertex 0).normal[2]

- bytes 32-63 represent vertex 1

etc...

## Skeletal Animation

Animations are stored in a .anim file. 

### Header

- Number of bones
- Number of keyframes

### Keyframe

- Beginning time
- Easing function
- Array of bones

#### Bone

Each bone is defined as a quaternion and vector to encode position and rotation. 

Each bone is independent and has no connection to a parent or child bone. For this reason, if a connection between two bones is present it has to be applied directly to the bone keyframes at compile time.


Here is the vertex declaration:


Vertex declaration 08F0DA20
{ Stream = 0, Offset = 0, Type = D3DDECLTYPE_FLOAT3, Method = D3DDECLMETHOD_DEFAULT, Usage = D3DDECLUSAGE_POSITION, UsageIndex = 0 },
{ Stream = 0, Offset = 12, Type = D3DDECLTYPE_FLOAT3, Method = D3DDECLMETHOD_DEFAULT, Usage = D3DDECLUSAGE_NORMAL, UsageIndex = 0 },
{ Stream = 0, Offset = 24, Type = D3DDECLTYPE_FLOAT3, Method = D3DDECLMETHOD_DEFAULT, Usage = D3DDECLUSAGE_BLENDWEIGHT, UsageIndex = 0 },
{ Stream = 0, Offset = 36, Type = D3DDECLTYPE_D3DCOLOR, Method = D3DDECLMETHOD_DEFAULT, Usage = D3DDECLUSAGE_BLENDINDICES, UsageIndex = 0 },
{ Stream = 0, Offset = 40, Type = D3DDECLTYPE_FLOAT2, Method = D3DDECLMETHOD_DEFAULT, Usage = D3DDECLUSAGE_TEXCOORD, UsageIndex = 0 }


Here is the vertex shader/pixel shader generated by the engine I'm working on.


//--------------------------------------------------------------------------------------
// Automatically generated vertex shader
//
// Copyright © Steve Segreto. All rights reserved.
//--------------------------------------------------------------------------------------
struct Mtrl
{
	float4 ambient;
	float4 diffuse;
	float4 spec;
	float specPower;
	float4 emissive;
};

struct DirLight
{
	float4 ambient;
	float4 diffuse;
	float4 spec;
	float3 dirW;
};

//--------------------------------------------------------------------------------------
// Macro defines
//--------------------------------------------------------------------------------------
#define MATRIX_PALETTE_SIZE (50)

//--------------------------------------------------------------------------------------
// Global variables
//--------------------------------------------------------------------------------------
uniform extern float4x4 gWorld;
uniform extern float4x4 gInvWorld;
uniform extern float4x4 gWVP;
uniform extern float3 gEyePosW;
uniform extern float gFogRange = 250.0f;
uniform extern float gFogStart = 1.0f;
uniform extern Mtrl gMtrl;
uniform extern DirLight gLight;
uniform extern matrix amPalette[ MATRIX_PALETTE_SIZE ];
uniform extern float gNumBones;

//----------------------------------------------------------------------------
// Shader body - VS_ Skin
//----------------------------------------------------------------------------

//
// Define the inputs -- caller must fill this, usually right from the VB.
//
struct VS_SKIN_INPUT
{
	float4 vPos;<BR>
	float3 vNor;<BR>
	float3 vBlendWeights;
	float4 vBlendIndices;
};

//
// Return skinned position and normal
//
struct VS_SKIN_OUTPUT
{
	float4 vPos;
	float3 vNor;
};

//
// Call this function to skin VB position and normal.
//
VS_SKIN_OUTPUT VS_Skin( const VS_SKIN_INPUT vInput, int iNumBones )
{
	VS_SKIN_OUTPUT vOutput = (VS_SKIN_OUTPUT) 0;<BR>
	float afBlendWeights[ 3 ] = (float[ 3 ]) vInput.vBlendWeights;<BR>
	float fLastWeight = 1.0f - afBlendWeights[ 0 ];<BR>
	int aiIndices[ 4 ] = (int[ 4 ]) D3DCOLORtoUBYTE4( vInput.vBlendIndices );<BR>
	float2x4 dual = (float2x4)0;<BR>
	float2x4 m = (float2x4)amPalette[ aiIndices[ 0 ] ];<BR>
	float4 dq0 = (float1x4)m;<BR>
	float4 dq;
	
	dual = afBlendWeights[ 0 ] * m;<BR>
	for( int iBone = 1; (iBone &lt; 3) && (iBone &lt; iNumBones - 1); ++ iBone )<BR>
	{
		fLastWeight -= afBlendWeights[ iBone ];
		m = (float2x4)amPalette[ aiIndices[ iBone ] ];
		dq = (float1x4)m;<BR>
		if (dot( dq0, dq ) &lt; 0)<BR>
		{<BR>
		dual -= afBlendWeights[ iBone ] * m;<BR>
		}<BR>
		else<BR>
		{<BR>
			dual += afBlendWeights[ iBone ] * m;<BR>
		}<BR>
	}<BR>
	<BR>
	m = (float2x4)amPalette[ aiIndices[ iNumBones - 1 ] ];<BR>
	dq = (float1x4)m;<BR>
	if (dot( dq0, dq ) &lt; 0)<BR>
	{<BR>
		dual -= fLastWeight * m;<BR>
	}<BR>
	else<BR>
	{<BR>
		dual += fLastWeight * m;<BR>
	}<BR>
	<BR>
	//<BR>
	// Fast dual-quaternion skinning.<BR>
	//<BR>
	float length = sqrt(dual[0].w * dual[0].w + dual[0].x * dual[0].x + dual[0].y * dual[0].y + dual[0].z * dual[0].z);<BR>
	dual = dual / length;<BR>
	vOutput.vPos.xyz = vInput.vPos.xyz + 2.0 * cross(dual[0].xyz, cross(dual[0].xyz, vInput.vPos.xyz) + dual[0].w * vInput.vPos.xyz);<BR>
	float3 translation = 2.0 * (dual[0].w * dual[1].xyz - dual[1].w * dual[0].xyz + cross(dual[0].xyz, dual[1].xyz));<BR>
	vOutput.vPos.xyz += translation;<BR>
	vOutput.vNor = vInput.vNor + 2.0 * cross(dual[0].xyz, cross(dual[0].xyz, vInput.vNor) + dual[0].w * vInput.vNor);<BR>
	<BR>
	return vOutput;<BR>
}<BR>

struct VS_in<BR>
{<BR>
	float3 posL : POSITION0;<BR>
	float3 normalL : NORMAL0;<BR>
	float3 BlendWeights : BLENDWEIGHT;<BR>
	float4 BlendIndices : BLENDINDICES;<BR>
	float2 tex0 : TEXCOORD0;<BR>
};<BR>
<BR>
struct VS_out<BR>
{<BR>
	float4 posH : POSITION0;<BR>
	float2 tex0 : TEXCOORD0;<BR>
	float3 normalW : TEXCOORD1;<BR>
	float3 posW : TEXCOORD2;<BR>
	float4 color : COLOR0;<BR>
	float fogLerpParam : COLOR1;<BR>
};<BR>
<BR>
VS_out VS_Scene( VS_in i )<BR>
{<BR>
//<BR>
// Zero out our output.<BR>
//<BR>
VS_out o = (VS_out)0;<BR>
<BR>
//<BR>
// Skin VB inputs<BR>
//<BR>
VS_SKIN_INPUT vsi = { float4( i.posL, 1.0f ), i.normalL, i.BlendWeights, i.BlendIndices };<BR>
<BR>
VS_SKIN_OUTPUT vso = VS_Skin( vsi, gNumBones );<BR>
<BR>
//<BR>
// Transform normal to world space and pass along to be interpolated by rasterizer.<BR>
//<BR>
o.normalW = normalize(mul(float4(vso.vNor, 0.0f), gInvWorld).xyz);<BR>
<BR>
//<BR>
// Transform position to world space and pass along to be interpolated by rasterizer.<BR>
//<BR>
o.posW = mul( float4( vso.vPos.xyz, 1.0f ), gWorld).xyz;<BR>
<BR>
//<BR>
// Pass along material color to be interpolated by rasterizer.<BR>
//<BR>
o.color = gMtrl.diffuse;<BR>
<BR>
//<BR>
// Transform position to homogeneous clip space.<BR>
//<BR>
o.posH = mul( float4( vso.vPos.xyz, 1.0f ), gWVP);<BR>
<BR>
//<BR>
// Pass on texture coordinates to be interpolated in rasterization.<BR>
//<BR>
o.tex0 = i.tex0;<BR>
<BR>
//<BR>
// Compute vertex distance from camera in world space for fog calculation.<BR>
//<BR>
float dist = distance( float4( vso.vPos.xyz, 1.0f ), gEyePosW);<BR>
o.fogLerpParam = saturate((dist - gFogStart) / gFogRange);<BR>
<BR>
//<BR>
// Done--return the output.<BR>
//<BR>
return o;<BR>
}<BR>
<BR>
<BR>
<BR>
//--------------------------------------------------------------------------------------<BR>
// Automatically generated pixel shader<BR>
//<BR>
// Copyright © Steve Segreto. All rights reserved.<BR>
//--------------------------------------------------------------------------------------<BR>
struct Mtrl<BR>
{<BR>
float4 ambient;<BR>
float4 diffuse;<BR>
float4 spec;<BR>
float specPower;<BR>
float4 emissive;<BR>
};<BR>
<BR>
struct DirLight<BR>
{<BR>
float4 ambient;<BR>
float4 diffuse;<BR>
float4 spec;<BR>
float3 dirW;<BR>
};<BR>
<BR>
//--------------------------------------------------------------------------------------<BR>
// Macro defines<BR>
//--------------------------------------------------------------------------------------<BR>
<BR>
//--------------------------------------------------------------------------------------<BR>
// Global variables<BR>
//--------------------------------------------------------------------------------------<BR>
uniform extern float3 gEyePosW;<BR>
uniform extern float3 gFogColor;<BR>
uniform extern Mtrl gMtrl;<BR>
uniform extern DirLight gLight;<BR>
uniform extern texture gTex0;<BR>
<BR>
struct PS_in<BR>
{<BR>
float2 tex0 : TEXCOORD0;<BR>
float3 normalW : TEXCOORD1;<BR>
float3 posW : TEXCOORD2;<BR>
float4 color : COLOR0;<BR>
float fogLerpParam : COLOR1;<BR>
};<BR>
<BR>
sampler TexS0 = sampler_state<BR>{<BR>
Texture = &lt;gTex0&gt;;<BR>
MinFilter = Linear;<BR>
MagFilter = Linear;<BR>
MipFilter = Point;<BR>
AddressU = Wrap;<BR>
AddressV = Wrap;<BR>
};<BR>
<BR>
float4 PS_Scene( PS_in i ) : COLOR<BR>{<BR>
//<BR>
// Interpolated normals can become unnormal.<BR>
//<BR>
i.normalW = normalize(i.normalW);<BR>
<BR>
//<BR>
// Compute the vector from the vertex to the eye.<BR>
//<BR>
float3 toEye = normalize(gEyePosW - i.posW);<BR>
<BR>
//<BR>
// Determine diffuse light intensity on vertex.<BR>
//<BR>
float s = saturate(dot(gLight.dirW, i.normalW));<BR>
<BR>
//<BR>
// Compute the reflection vector.<BR>
//<BR>
float3 r = reflect( -gLight.dirW, i.normalW );<BR>
<BR>
//<BR>
// Determine how much specular light makes it into the eye.<BR>
//<BR>
float t = pow(saturate(dot(r, toEye)), gMtrl.specPower);<BR>
<BR>
//<BR>
// VERT_MODE_SRC_IGNORE<BR>
//<BR>
float3 matAmbient = saturate( gMtrl.ambient.rgb + float3( 0.8f, 0.8f, 0.8f ) );<BR>
float4 matDiffuse = gMtrl.diffuse;<BR>
float3 matEmissive = gMtrl.emissive.rgb;<BR>
<BR>
//<BR>
// Incoming color.<BR>
//<BR>
float3 color_stage0 = (matAmbient * gLight.ambient) +<BR>
(s * (matDiffuse * gLight.diffuse).rgb) +<BR>
matEmissive + (t * (gMtrl.spec * gLight.spec).rgb);<BR>
float alpha_stage0 = matDiffuse.a;<BR>
<BR>
//<BR>
// Sample textures.<BR> //<BR> float4 color0 = tex2D(TexS0, i.tex0);<BR><BR> //<BR> // Apply texturing stages<BR> //<BR><BR> //<BR> // Diffuse map.<BR> //<BR> float3 color_stage1 = color_stage0 * color0.rgb;<BR> alpha_stage0 = alpha_stage0 * color0.a;<BR><BR> //<BR> // Final (pre-fog) color.<BR> //<BR> float4 texColor = float4( color_stage1.r, color_stage1.g, color_stage1.b, alpha_stage0 );<BR><BR> //<BR> // Add fog<BR> //<BR> return ( lerp( texColor, float4( gFogColor, texColor.a ), i.fogLerpParam ));<BR>}<BR><BR><BR>This is the trickier part. If you adapt the DX9 MultiAnimation Sample, you can simply put this code in right after the sample creates<BR>the "working" palette of 4x4 matrices and right before it uploads them to the GPU.<BR><BR><BR>D3DXMatrixMultiply( &amp;m_pSceneGraph-&gt;m_amxWorkingPalette[ dwPalEntry ],<BR> &amp;( pMC-&gt;m_amxBoneOffsets[ dwMatrixIndex ] ),<BR> pMC-&gt;m_apmxBonePointers[ dwMatrixIndex ] );<BR>//<BR>// Add this for Dual-Quaternion Skinning.<BR>//<BR>D3DXQUATERNION q;<BR>D3DXQuaternionRotationMatrix( &amp;q, &amp;m_pSceneGraph-&gt;m_amxWorkingPalette[ dwPalEntry ] );<BR>D3DXVECTOR3 t = D3DXVECTOR3( m_pSceneGraph-&gt;m_amxWorkingPalette[ dwPalEntry ]._41,<BR> m_pSceneGraph-&gt;m_amxWorkingPalette[ dwPalEntry ]._42,<BR> m_pSceneGraph-&gt;m_amxWorkingPalette[ dwPalEntry ]._43 );<BR>D3DXMATRIX temp_Mat;<BR>D3DXVECTOR4 dual[2];<BR>UQTtoUDQ( dual, q, t );<BR>for (UINT j = 0; j &lt; 2; j++)<BR>{<BR> temp_Mat.m[j][0] = dual[j].x;<BR> temp_Mat.m[j][1] = dual[j].y;<BR> temp_Mat.m[j][2] = dual[j].z;<BR> temp_Mat.m[j][3] = dual[j].w;<BR>}<BR>m_pSceneGraph-&gt;m_amxWorkingPalette[ dwPalEntry ] = temp_Mat;<BR><BR><BR>Also you will need to add this function somewhere in the MultiAnimationLib.cpp file:<BR><BR><BR>// convert unit quaternion and translation to unit dual quaternion<BR>void UQTtoUDQ( D3DXVECTOR4 dual[2], D3DXQUATERNION quat, D3DXVECTOR3 tran )<BR>{<BR> dual[0].x = quat.x;<BR> dual[0].y = quat.y;<BR> dual[0].z = quat.z;<BR> dual[0].w = quat.w;<BR> dual[1].x = 0.5f * ( tran[0] * quat.w + tran[1] * quat.z - tran[2] * quat.y );<BR> dual[1].y = 0.5f * (-tran[0] * quat.z + tran[1] * quat.w + tran[2] * quat.x );<BR> dual[1].z = 0.5f * ( tran[0] * quat.y - tran[1] * quat.x + tran[2] * quat.w );<BR> dual[1].w = -0.5f * (tran[0] * quat.x + tran[1] * quat.y + tran[2] * quat.z );<BR>} <BR>